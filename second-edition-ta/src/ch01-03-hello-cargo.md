## வணக்கம், சரக்கு!

சரக்கு என்பது இரஸ்ட்டின் கட்டட அமைப்பு மற்றும் தொகுப்பு மேலாளர். பெரும்பாலான இரஸ்டாசன்கள் இந்த கருவியை பயன்படுத்துகின்றனர்
சரக்குகள் உங்கள் நிறைய பணிகளை கையாள்கின்றன என்பதால்,இரஸ்ட் திட்டங்களை நிர்வகிக்க,
உங்கள் குறியீட்டை உருவாக்குவது, உங்கள் குறியீடு சார்ந்து நூலகங்கள் பதிவிறக்கம் செய்வது
, மற்றும் நூலகங்களை உருவாக்குவது போன்ற பணிகளை செய்கின்றன. 
 (உங்கள் குறியீடு தேவை * நூலகங்கள் * சார்புகளை நூலகங்கள் அழைக்கிறோம்.)
(We call libraries your code needs *dependencies*.)
எளிமையான இரஸ்ட் நிகழ்ச்சிகள், நாம் இதுவரை எழுதியுள்ளதைப் போலவே
சார்புநிலைகளாகவும் எதுவும் குறிப்பிடப்படவில்லை. நாம் ஹலோ, உலகத்தை கட்டியிருந்தால்! சரக்கு திட்டத்தின் மூலம், அது உங்கள் குறியீட்டை உருவாக்கும் கர்கோவின் பகுதியை மட்டும் பயன்படுத்துங்கள். 
நீங்கள் இன்னும் எழுதும்போது சிக்கலான இரஸ்ட் திட்டத்தின் மூலம், நீங்கள் சார்புகளை சேர்க்க வேண்பெரும்பாலான இரஸ்ட் திட்டங்களில் சரக்குகள், மற்றும் புத்தகத்தின் மற்ற பகுதிகள் பயன்படுத்தப்படுகின்றன
நீங்கள் கூட சரக்கு பயன்படுத்த வேண்டும் என்று கருதுகிறது. நீங்கள் என்றால் ரஸ்ட் கொண்டு சரக்கு நிறுவப்பட்டது
"நிறுவல்" பிரிவில் விவாதிக்கப்பட்ட அதிகாரப்பூர்வ நிறுவிகளைப் பயன்படுத்தினார். நீங்கள் என்றால்
வேறு சில வழிகளிலும் ரஸ்ட் நிறுவப்பட்டது, சரக்கு நிறுவப்பட்டதா என சரிபார்க்கவும்

உங்கள் முனையத்தில் கீழ்க்கண்டவற்றை உள்ளிடுக:டும், மற்றும் நீங்கள் ஒரு திட்டத்தை ஆரம்பித்தால்
சரக்கு பயன்படுத்தி, சார்புகளை சேர்ப்பது மிகவும் எளிதாக இருக்கும்.

```text
$ cargo --version
```

நீங்கள் ஒரு பதிப்பு எண்ணைக் கண்டால், உங்களிடம் இது உள்ளது! `கட்டளை போன்ற ஒரு பிழை நீங்கள் கண்டால் அது கட்டளை`, உங்கள் நிறுவல் முறையை ஆவணத்தில் பாருங்கள்
தனித்தனியாக சரக்கு நிறுவ எப்படி தீர்மானிக்க.

### சரக்கு மூலம் ஒரு திட்டத்தை உருவாக்குதல்
சரக்கு பயன்படுத்தி ஒரு புதிய திட்டத்தை உருவாக்குவோம் மற்றும் அது வணக்கம், உலகம்! என்ற திட்டத்திலிருந்து எப்படி வேறுபடுகிறது என்று பார்ப்போம்.
உங்களின்  திட்ட இயக்கத்தை  அடைவுக்குள் திரும்ப பெறவும் (அல்லது
எங்கு உங்கள் குறியீட்டை சேமித்து வைக்க முடிவு செய்தீர்கள்). பின்னர், எந்த இயக்க முறைமையிலும், பின்வருவதை இயக்கவும்:	
```text
$ cargo new hello_cargo --bin
$ cd hello_cargo
```
முதல் கட்டளை, * hello_cargo * என்ற புதிய பைனரி இயங்கமைப்பு உருவாக்குகிறது.`-bin`ஆர்குயுமன்டை `cargo new`ற்கு அனுப்பி ஒரு நிறைவேற்றக் கூடிய பயன்பாட்டை
ஒரு நூலகத்திற்கு பதிலாக உருவாக்குவோம்(அடிக்கடி
ஒரு பைனரி * என்று அழைக்கப்படுகிறது) ஒரு நூலகத்திற்கு பதிலாக. எங்கள் திட்டத்தை* hello_cargo * என்று பெயரிட்டோம், மற்றும் சரக்கு அதன் கோப்புகளை அதே பெயரின் அடைவில் உருவாக்குகிறது.

Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the “Installation” section. If you
installed Rust through some other means, check whether Cargo is installed by
entering the following into your terminal:

```text
$ cargo --version
```

If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.


Hello_cargo * கோப்பறையில் சென்று கோப்புகளை பட்டியலிடுங்கள். நீங்கள் சரக்கை பார்க்கும் போது,சரக்கு இரண்டு கோப்புகள் மற்றும் ஒரு அடைவு உருவாக்கியது: a * Cargo.toml * கோப்பு மற்றும் ஒரு
* src * கோப்பினை உள்ளே * main.rs * கோப்பில் கொண்டிருக்கும். இது ஒரு புதிய கிட் துவக்கி
* .gitignore * கோப்பினை இணைக்கும் களஞ்சியத்தையும் கொண்டிருக்கும்.

குறிப்பு: Git ஒரு பொது பதிப்பு கட்டுப்பாட்டு அமைப்பு. நீங்கள் `cargo new` என்று மாற்றலாம் வேறுபட்ட பதிப்பு கட்டுப்பாட்டு அமைப்பு அல்லது பதிப்பு கட்டுப்பாட்டு முறைமையைப் பயன்படுத்துவதன் மூலமாக
  `-vcs` கொடி பயன்படுத்தலாம். ஏற்கனவே இருக்கும் விருப்பங்களைக் காண `சரக்கு புதிய --help` ஐ இயக்கவும்.

  
   உங்கள் உரை ஆசிரியரில் * Cargo.toml * தேர்வு செய்து திறக்கவும். அது போலவே பட்டியல் 1-2 வேண்டும்.

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]

[dependencies]
```

<span class="caption">Listing 1-2:* Cargo.toml இன் பொருளடக்கம் * சரக்கு மூலம் உருவாக்கப்பட்டது</span>

இந்த கோப்பு [* TOML *] [toml] இல் உள்ளது <! --ignore--> (* டாம்'ஸ் வெளிப்படையான, குறைந்தபட்சம்
மொழி *) வடிவம், இது கார்கோவின் கட்டமைப்பு வடிவமாகும்.

[toml]: https://github.com/toml-lang/toml

`[தொகுப்பு]`,இதன் முதல் வரி ஒரு பகுதி தலைப்பு என்று குறிக்கிறது
பின்வரும் அறிக்கைகள் ஒரு தொகுப்பை கட்டமைக்கிறது. மேலும் தகவலைச் சேர்ப்பது போல
இந்த கோப்பு, நாம் பிற பிரிவுகளை சேர்க்க வேண்டும்.


அடுத்த மூன்று கோடுகள் கார்கோவை தொகுக்க வேண்டிய கட்டமைப்பு தகவலை அமைக்கும் திட்டத்தை : பெயர், பதிப்பு, மற்றும் அது யார் எழுதியது என்பதை செய்கிறது.
 சரக்கு உங்கள் பெயர் மற்றும் மின்னஞ்சல் தகவலை  உங்கள் சூழலில் இருந்து பெறுகிறது , அந்த தகவல் சரியாக இல்லை என்றால், தகவலை சரிசெய்து பின்னர் கோப்பை சேமிக்கவும்.


கடைசி வரியில், [dependencies], ஒரு பிரிவில் ஆரம்பம் ஆகும் எந்த பட்டியலும் உங்கள் திட்டத்தின் சார்புகள். 
இரஸ்ட் இல், குறியீட்டு தொகுப்புகள் crates என குறிப்பிடப்படுகின்றன.
 இந்த திட்டத்திற்கான வேறு எந்த கோடுகளும் எங்களுக்கு தேவையில்லை, 
ஆனால் நாங்கள் பாடம் 2 இல் முதல் திட்டத்தில் நாம் இந்த சார்புகளை பிரிவைப் பயன்படுத்துவோம்.
 src / main.rs ஐ திறந்து ஒரு முறை பாருங்கள்:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

கார்கோ, வணக்கம், உலகம் என்ற திட்டத்தை உங்களுக்காக உருவாக்கியுள்ளது! நாங்கள் எழுதப்பட்டதைப் போலவே, உங்களுக்காகவும் திட்டம்
பட்டியல் 1-1 இல்! இதுவரை, எங்கள் முந்தைய திட்டம் மற்றும்  cargo திட்டம் இடையே வேறுபாடுகள்
திட்டம் உருவாக்குகிறது cargo * குறியீட்டை * src * அடைவில் வைக்க வேண்டும்,
மற்றும் நாம் மேலே உள்ள அடைவில் * Cargo.toml * என்ற கட்டமைப்பு கோப்பு உள்ளது.

உங்கள் மூல கோப்புகளை * src * அடைவு உள்ளே கார்கோ எதிர்பார்க்கிறது.
மேல்-நிலை திட்ட அடைவில் README கோப்புகள், உரிமம் தகவல்,
கட்டமைப்பு கோப்புகள் மற்றும் உங்கள் குறியீடு தொடர்பான வேறு எதுவும் இல்லை. கார்கோ
உங்களது திட்டங்களை ஒழுங்கமைக்க உதவுகிறது. எல்லாம் ஒரு இடத்திலும், மற்றுவை
எல்லாம் அதன் இடத்திலும் உள்ளது.

நீங்கள் கர்கோவைப் பயன்படுத்தமால் வணக்கம் உலகம்! திட்டத்தை ஆரம்பித்திருந்தால்,
கார்கோவை திட்டத்தை பயன்படுத்தி மாற்ற முடியும்.
திட்டத்தின் குறியீட்டை* src * கோப்பகத்தில் நகர்த்தவும் மற்றும் * Cargo.toml * 
என்ற பொருத்தமான திட்டத்தை உருவாக்கலாம்.

### ஒரு கார்கோ திட்டத்தின் கட்டமைப்பு மற்றம் ஓட்டம்

இப்போது நாம் ஹலோ, உலகத்தை உருவாக்க மற்றும் ரன் செய்யும் போது வித்தியாசமாக என்ன பார்க்கலாம்!
சரக்கு கொண்டு திட்டம்! உங்கள் * hello_cargo * அடைவிலிருந்து, உங்கள் திட்டத்தை உருவாக்கவும்
பின்வரும் கட்டளையை உள்ளிடவும்:

```text
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

இந்த கட்டளை இயங்ககூடிய இயக்கத்தை *target / debug / hello_cargo * இல் (அல்லது
*target \ debug \ hello_cargo.exe * விண்டோஸ் இல்) உங்கள் தற்போதைய அடைவைவிட இங்கு உருவாக்கும்.
இந்த கட்டளையுடன் இயங்கக்கூடிய இயக்கத்தை இயக்கலாம்

```text
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

எல்லாம் நன்றாக நடந்தால், `ஹலோ, உலகம் !`என்பதை முனையத்தில் அச்சிட வேண்டும்.
முதல் முறையாக Cargo build , ஒரு புதிய கோப்பை  cargo-வின் மேல்  * Cargo.lock *உருவாக்குகிறது
நிலை: * Cargo.lock *. இந்த கோப்பின் சரியான பதிப்புகளைக் 
உங்கள் திட்டத்தின் சார்புகள் கண்காணிக்கும். இந்த திட்டத்தில் சார்பு இல்லை, எனவே
கோப்பு சிறிது சிறிதாக உள்ளது. நீங்கள் எப்போதும் இந்த கோப்பை கைமுறையாக மாற்ற வேண்டியதில்லை; சரக்கு
உங்களுக்கான உள்ளடக்கங்களை நிர்வகிக்கிறது.

நாங்கள் `cargo build` என்ற ஒரு திட்டத்தை உருவாக்கி அதை ஓடினோம்
`./target/debug/hello_cargo`-ல் ஓட்டினோம், ஆனால் நாங்கள்  `cargo run`ஐ பயன்படுத்தி 
குறியீட்டை தொகுக்கவும் மற்றும் ஒரே கட்டளையில்  அனைத்து நிறைவேற்றக்கூடியவனற்றையும் இயக்க வேண்டும்:

```text
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`.இந்த நேரத்தில் cargo என்று கூறுவதை வெளியீடு காணவில்லை என்பதை கவனிக்கவும்
`Hello_cargo`. சரக்குகள் மாற்றப்படவில்லை என்று சரக்கு கண்டுபிடித்தது, இது 
பைனரியில் இயக்கிவிட்டது. உங்கள் மூல குறியீடு மாற்றியிருந்தால், cargo வை  மீண்டும் இயக்கம் முன் அந்த திட்டத்தை கட்டியிருக்க வேண்டும்,மற்றும் நீங்கள் இந்த வெளியீட்டை பார்த்திருப்பீர்கள்:

```text
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

கார்கோ `cargo casa` என்று அழைக்கப்படும் ஒரு கட்டளையை வழங்குகிறது. இந்த கட்டளை உங்கள் குறியீட்டைவிரைவில் சரிபார்க்கிறது,
 அது தொகுக்கப்பட்டுள்ளது என்பதை  ஆனால் இயங்கக்கூடியதாக உறுதி செய்யவில்லை: 

```text
$ cargo check
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

நீங்கள் செயல்பட விரும்பாதது ஏன்? பெரும்பாலும், `cargo check`யை விட விரைவாக உள்ளது
`cargi  build`, ஏனெனில் அது இயங்கக்கூடிய ஒரு உற்பத்தியைத் தடுக்கிறது. நீங்கள்
`cargo check` பயன்படுத்தி, குறியீட்டை எழுதும் போது உங்கள் வேலையை தொடர்ந்து கண்காணித்து வரும் போது
செயல்முறை வேகமாகிறது!. அத்துடன், பல ரஷ்யர்கள் `கார்கோ காசோலை` அவ்வப்போது இயங்குகிறார்கள்
அவர்கள் தங்கள் நிரலை எழுதுவது உறுதிப்படுத்துகிறது. பின்னர் அவர்கள் தயாராக இருக்கும் போது `cargo build` இயக்கப்படுகிறது.

நாம் இதுவரை கர்கோவைப் பற்றி கற்றுக்கொண்டவற்றை மீண்டும் பார்ப்போம்:

*`cargo build` அல்லது` சரக்குச் சரிபார்ப்பாக` பயன்படுத்தி ஒரு திட்டத்தை உருவாக்க முடியும்.
* `cargo run` பயன்படுத்தி ஒரு படிவத்தில் ஒரு திட்டத்தை உருவாக்க முடியும்.
* எங்கள் குறியீட்டில் அதே அடைவில் உருவாக்கத்தின் விளைவை சேமிப்பதற்கு பதிலாக,
   target* debug / பிழைத்திருத்தம் * அடைவில் சேமிக்கிறது.
   
cargo-வைப் பயன்படுத்துவதற்கான ஒரு கூடுதலான நன்மை, கட்டளைகள் அதே இல்லை
நீங்கள் பணிபுரியும் இயங்குதளம் இதுவே. எனவே, இந்த கட்டத்தில், நாம் இல்லை
லினக்ஸ் மற்றும் MacOS மற்றும்  Windows க்கான குறிப்பிட்ட வழிமுறைகளை இனி வழங்குகின்றன.

### வெளியீட்டுக்கான கட்டிடம்

When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.

### ஒப்பந்தம் போன்ற cargo

எளிமையான திட்டங்களுடனான, cargo, இரஸ்ட்டை பயன்படுத்தும் போது நிறைய மதிப்புகளை வழங்கவில்லை, ஆனால் உங்கள் திட்டங்கள் இன்னும் சிக்கலானதாகி விட்டால் அதன் மதிப்பை நிரூபிக்கும்.
பல அடுக்குகள் கொண்ட சிக்கலான திட்டங்களுடன்,
சரக்கு ஒருங்கிணைத்து கட்டமைக்கும் போது மிகவும் எளிதானதாக இருக்கும்.

`Hello_cargo` திட்டம் எளிதானது என்றாலும், அது இப்போது உண்மையானதைப் கருவிகளை பயன்படுத்தி நீங்கள் இரஸ்ட்டின் மீதி வாழ்க்கையை உபயோகிக்கலாம். உண்மையில்,
ஏற்கனவே இருக்கும் திட்டத்தில் வேலை செய்தால், நீங்கள் G it ஐ பயன்படுத்தி குறியீட்டை சரிபார்க்க பின்வரும் கட்டளைகளை பயன்படுத்தலாம்
, அந்த திட்டத்தை கோப்பகத்திற்கு மாற்றவும், உருவாக்கவும்:

```text
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```

கார்கோ பற்றிய கூடுதல் தகவலுக்கு, அதன் ஆவணமாக்கலைப் பார்க்கவும்.

[its documentation]: https://doc.rust-lang.org/cargo/

## சுருக்கம்

உங்கள் ரஸ்ட் பயணத்தில் ஒரு பெரிய துவக்கத்திற்கு நீங்கள் ஏற்கனவே முற்றுப்புள்ளி வைத்திருக்கிறீர்கள்! இந்த அத்தியாயத்தில்,
நீங்கள் எப்படி கற்றுக்கொண்டீர்கள்:

* 'Rustup` ஐ பயன்படுத்தி ரஸ்டின் சமீபத்திய நிலையான பதிப்பை நிறுவவும்
* புதிய ரஸ்ட் பதிப்பு புதுப்பிக்கவும்
* நிறுவப்பட்ட ஆவணங்களை திறக்க
* ஒரு வணக்கம் எழுதுங்கள், உலகத்தை எழுதுங்கள்! திட்டத்தை நேரடியாக `rustc` பயன்படுத்துகிறது
* கார்கோவின் மரபுகளை பயன்படுத்தி ஒரு புதிய திட்டத்தை உருவாக்கவும், இயக்கவும்

இது வாசிப்பதற்குப் பழக்கமான ஒரு மிகப்பெரிய வேலைத்திட்டத்தை உருவாக்க இது ஒரு சிறந்த நேரம்
மற்றும் ரஸ்ட் குறியீடு எழுதுதல். எனவே, பாடம் 2 ல், நாம் ஒரு யோசிக்கிற விளையாட்டு திட்டம் உருவாக்க வேண்டும்.
நீங்கள் சாதாரண நிரலாக்க கருத்துக்கள் எவ்வாறு இயங்குகிறீர்கள் என்பதைக் கற்றுக் கொள்வதன் மூலம் ஆரம்பிக்க வேண்டும்
ரஸ்ட், பாடம் 3 ஐப் பார்க்கவும், பின்னர் பாடம் 2 க்கு திரும்பவும்.
